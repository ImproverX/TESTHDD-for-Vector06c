;(перед компилированием преобразовать в KOI-8R)
	.ORG    00100h
#DEFINE BufHDD1	BufHDD0		; буфер для сохранения сектора диска при тесте
#DEFINE BufHDD2 BufHDD1+512+16	; второй буфер
#DEFINE BufHDD3 BufHDD2+512+16	; паттерн для теста записи
;
L_0100:	CALL    L_0A08	; вывод строки и отбивки дефисами
	.db 01Bh, 05Bh, "$"	;Ch, 01Bh, 05Eh, "$"
	CALL    L_0A08	; вывод строки и отбивки дефисами
	.db "ТЕСТ НАКОПИТЕЛЯ НА ЖЕСТКОМ "
	.db "МАГНИТНОМ ДИСКЕ.$"
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "В.ФРОЛОВ 1995 / Improver 2026$"
	LXI  SP,08000h
L_014E: CALL    L_0A08	; вывод строки и отбивки дефисами
	.db "Начало поверхностного теста "
	.db "портов$"
L_0174: OUT     05Fh	; полный сброс НЖМД
	PUSH D		; << ожидание готовности НЖМД
	PUSH B
	MVI  D, 020h	; 20h * 10000h -- сколько ждать
L_017X: IN      057h	; Чтение: регистр статуса
	ANI     0C0h	; маскируем готовность НЖМД
	CPI     040h
	JZ      L_01B2	; >> готов
	DCX  B
	MOV  A, B
	ORA  C
	JNZ     L_017X
	DCR  D
	JNZ     L_017X
	CALL    L_0A7B	; вывод ошибки (?)
	.db "не работает порт OUT 5F, "
	.db "или IN/OUT 57 у НЖМД$"
	JZ      L_0174
L_01B2:	LXI  B, 08000h	; счётчик
L_01BG:	IN      057h	; регистр статуса
	CPI	0FFh
	JNZ	L_01BX	;
	DCR  C
	JNZ	L_01BG
	CALL    L_0A7B	; вывод ошибки (?)
	.db "не работает порт IN 57$"
	JZ      L_01B2
L_01BX:	ANI     002h	; индекс, трактуется особо каждым производителем (?)
	MOV  E, A	; заносим в E значение второго бита
L_01B5: IN      057h	; регистр статуса
	ANI     002h
	CMP  E
	JNZ     L_024D	; выход, если второй бит изменился
	DCX  B
	MOV  A, B
	ORA  C
	JNZ     L_01B5	; цикл 32768 раз
	CALL    L_0A5C	; вывод строки далее до "$"
	.db 00Dh, 00Ah, " IN 57 ->$"
	IN      057h
	MOV  L, A
	MVI  H, 000h
	CALL    L_0B3F	; вывод значения из HL
	CALL    L_0A7B	; вывод ошибки (?)
	.db "не работает порт IN 57 или "
	.db "индексный маркер у НЖМД "
	.db "(не ошибка)$"
	JZ      L_01B2
;
L_024D: MVI  B, 053h
L_024F: MOV  A, B
	STA     Lx025B+1
	STA     Lx0259+1
	MVI  C, 000h
L_0258: MOV  A, C
Lx0259:	OUT     000h	; <<< правится порт
Lx025B:	IN      000h	; <<< правится порт
	CMP  C
	JZ      L_0285
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "не работает порт $"
	MOV  A, B
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	CALL    L_0A7B	; вывод ошибки (?)
	.db " $"
	JZ      L_024F
	JMP     L_0289
;
L_0285: INR  C
	JNZ     L_0258
L_0289: INR  B
	MOV  A, B
	CPI     056h	; 55h???
	JNZ     L_024F
L_0290: MVI  C, 000h
L_0292: MOV  A, C
	ORI     0A0h	; 1010 0000	
	OUT     056h	; Биты определяют устройство и головку для операции чтения/записи, режим CHS
	IN      056h
	ANI     00Fh
	CMP  C
	JZ      L_02D6
	CALL    L_0A7B	; вывод ошибки (?)
	.db "не работает порт 56 или НЖМД "
	.db "включен не как нулевой$"
	JZ      L_0290
L_02D6: INR  C
	MOV  A, C
	CPI     010h
	JNZ     L_0292
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "текущие данные в портах: $"
;	MOV  A, B
	IN	051h
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	IN	052h
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	IN	053h
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	IN	054h
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	IN	055h
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	IN	056h
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	IN	057h
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
;
	CALL    L_0AA3	; вывод сообщения о продолжении
	.db "Конец поверхностного теста "
	.db "портов$"
	JZ      L_014E
	CALL    L_0A08	; вывод строки и отбивки дефисами
	.db "Начало внутренней "
	.db "диагностики НЖМД$"
L_0329:;	MVI  A, 010h	; 1xH = сброс на цилиндр 0 (x = step rate)
;	OUT     057h	; Запись:	регистр команды
	MVI  A, 090h	; 90H = диагностика
	OUT     057h	; регистр команды
	CALL    L_D9D9	; ожидание готовности НЖМД
	JNC     L_0349
	CALL    L_0B6N	; вывод A в шестнадцатиричном формате с новой строки
	CALL    L_0A7C	; вывод ошибки (?) без перевода строки
	.db ": не готов НЖМД$"
	JZ      L_0329
	JMP     L_0438
;
L_0349: IN      051h	; Регистр ошибок
;	CPI     001h
;	JZ      L_038E
	CPI     002h
	JC      L_038E
	JZ      L_03B6
	CPI     003h
	JZ      L_03DC
	CPI     005h
	JZ      L_03FC
	CPI     006h
	JZ      L_041C
	MOV  B, A
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "неисправен порт OUT 57 или "
	.db "IN 51 = $"
	MOV  A, B
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	CALL    L_0A7B	; вывод ошибки (?)
	.db " $"
;	CALL    L_0A7B	; вывод ошибки (?)
;	.db "неисправен порт OUT 57 или "
;	.db "IN 51$"
	JZ	L_0329
	JMP     L_0438
;
L_038E: CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "нет ошибок внутренней "
	.db "диагностики$"
	JMP     L_0438
;
L_03B6: CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Ошибка встроенного адаптера "
	.db "НЖМД$"
	JMP     L_0438
;
L_03DC: CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Ошибка буфера сектора НЖМД$"
	JMP     L_0438
;
L_03FC: CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Ошибка аппаратуры ECC НЖМД$"
	JMP     L_0438
;
L_041C: CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Ошибка процессора НЖМД$"
	JMP     L_0438
;
L_0438: CALL    L_0AA3	; вывод сообщения о продолжении
	.db "Конец внутренней диагностики "
	.db "НЖМД$"
	JZ      L_0329
L_045F: CALL    L_0A08	; вывод строки и отбивки дефисами
	.db "Определение параметров НЖМД$"

L_047G:	CALL	L_D8DC	; сброс и проверка готовности НЖМД
;	MVI  A, 010h	; 1xH = сброс на цилиндр 0 (x = step rate)
;	OUT     057h	; Запись:	регистр команды
;	CALL	L_D9D9	; проверка готовности НЖМД
	MVI  A, 0E0h	; 1110 0000
	OUT     056h	; режим, выбор устройства 0
	MVI  A, 0ECh	; ECH = идентификация устройства (получение данных о конфигурации)
	OUT     057h	; регистр команды
	CALL	L_D9D9	; проверка готовности НЖМД
	ANI     008h	; 0000 1000 :	запрос данных. Буфер ждет данных (занято)
	JNZ     L_047X
	CALL	L_D9F9	; получение кода ошибки 2
	CALL    L_0B6N	; вывод A в шестнадцатиричном формате с новой строки
	CALL    L_0A7C	; вывод ошибки (?) без перевода строки
	.db ": не готов НЖМД$"
;	JZ      L_047G
	JMP     L_047G
;
L_047X:	MVI  D, 000h	; D=0
	LXI  H,	BufHDD2	; второй буфер
	CALL	L_D8C1	; чтение данных
	JNC	L_04N0	; всё ок
	CALL    L_0B6N	; вывод A в шестнадцатиричном формате с новой строки
	CALL    L_0A7C	; вывод ошибки (?) без перевода строки
	.db ": не читаются параметры НЖМД$"
	JZ	L_047G	; повторить
	JMP	L_04E2	; продолжить
;
L_04ER:	CALL    L_0A56	; вывод строки далее до "$"
	.db "Cекторов$"
	LHLD	BufHDD2+12	; число секторов из ID
	CALL    L_0B3F	; вывод числа из HL
	CALL    L_0A5C	; вывод строки далее до "$" без ПС
	.db ", головок$"
	LHLD	BufHDD2+6	; число головок из ID
	CALL    L_0B3F	; вывод числа из HL
	CALL    L_0A5C	; вывод строки далее до "$" без ПС
	.db ", цилиндров$"
	LHLD    BufHDD2+2	; число цилиндров из ID
	CALL    L_0B3F	; вывод числа из HL
	CALL    L_0A7B	; вывод ошибки (?)
	.db "получены неправильные "
	.db "параметры НЖМД", 00Dh, 00Ah
	.db "неисправен порт IN 50/58$"
	JZ	L_047G
L_04E2:	CALL    L_0A56	; вывод строки далее до "$"
	.db "Подбор значений$"
L_047C:	MVI  A, 010h	; 1xH = сброс на цилиндр 0 (x = step rate)
	OUT     057h	; Запись:	регистр команды
	MVI  B, 001h
L_047E: CALL    L_0AF5	; "Прервать?"
	JZ      L_04CA
;	CALL    L_0E2C	; сброс НЖМД и ожидание готовности
	CALL	L_D8DC	; сброс и проверка готовности НЖМД
	JC	L_047Y	; >> ошибка
	MVI  A, 001h
	OUT     052h	; Счетчик числа секторов для операции чтения/записи
	MOV  A, B
	OUT     053h	; Номер логического сектора для чтения/записи
	XRA  A
	OUT     054h	; Цилиндр, младшие биты
	OUT     055h	; Цилиндр, старшие биты
	MVI  A, 0A0h	; 1010 0000	
	OUT     056h	; Биты определяют устройство и головку для операции чтения/записи, режим CHS
	MVI  A, 001h	; (не быстрая верификация)
	CALL    L_VRF	; верификация сектора
	JNZ     L_04CA	; >> ошибка
	INR  B
	JNZ     L_047E	; цикл по секторам
L_047Y:	CALL    L_0A7B	; вывод ошибки (?)
	.db "вычисление числа секторов "
	.db "на дорожке$"
	JZ      L_047C
L_04CA:	MOV  L, B
	MVI  H, 000h
	DCX  H
	SHLD    BufHDD2+12	; число секторов
	CALL    L_DOT	; вывод точки
L_04FD:	MVI  A, 010h	; 1xH = сброс на цилиндр 0 (x = step rate)
	OUT     057h	; Запись:	регистр команды
	MVI  B, 0A0h	; 1010 0000	
L_04FF: CALL    L_0AF5	; "Прервать?"
	JZ      L_0523
;	CALL    L_0E2C	; сброс НЖМД и ожидание готовности
	CALL	L_D8DC	; сброс и проверка готовности НЖМД
	JC	L_04FY	; >> ошибка
	MVI  A, 001h
	OUT     052h	; Счетчик числа секторов для операции чтения/записи
	OUT     053h	; Номер логического сектора для чтения/записи
	XRA  A
	OUT     054h	; Цилиндр, младшие биты
	OUT     055h	; Цилиндр, старшие биты
	MOV  A, B
	OUT     056h	; Биты определяют устройство и головку для операции чтения/записи, режим CHS
	MVI  A, 001h	; (не быстрая верификация)
	CALL    L_VRF	; верификация сектора
	JNZ     L_0523	; >>
	INR  B
	MOV  A, B
	CPI     0B1h
	JC	L_04FF	; цикл по головкам
L_04FY:	CALL    L_0A7B	; вывод ошибки (?)
	.db "вычисление числа головок$"
	JZ      L_04FD
L_0523:	MVI  A, 01Fh
	ANA  B
	MOV  L, A
	MVI  H, 000h
	SHLD    BufHDD2+6	; число головок
	CALL    L_DOT	; вывод точки
L_0550:	MVI  A, 010h	; 1xH = сброс на цилиндр 0 (x = step rate)
	OUT     057h	; Запись:	регистр команды
	LXI  H, 00000h
L_0553: CALL    L_0AF5	; "Прервать?"
	JZ      L_059C
;	CALL    L_0E2C	; сброс НЖМД и ожидание готовности
	CALL	L_D8DC	; сброс и проверка готовности НЖМД
	JC	L_055Y	; >> ошибка
	MVI  A, 001h
	OUT     052h	; Счетчик числа секторов для операции чтения/записи
	OUT     053h	; Номер логического сектора для чтения/записи
	MOV  A, L
	OUT     054h	; Цилиндр, младшие биты
	MOV  A, H
	OUT     055h	; Цилиндр, старшие биты
	MVI  A, 0A0h	; 1010 0000	
	OUT     056h	; Биты определяют устройство и головку для операции чтения/записи, режим CHS
	MVI  A, 001h	; (не быстрая верификация)
	CALL    L_VRF	; верификация сектора
	JNZ     L_059C
	INR  L
	JNZ     L_0553	; цикл по цилиндрам (L)
	PUSH H
	CALL    L_DOT	; вывод точки
	POP  H
	INR  H	
	MOV  A, H
	CPI     020h	; максимум 2000h
	JNZ     L_0553	; цикл по цилиндрам (H)
L_055Y:	CALL    L_0A7B	; вывод ошибки (?)
	.db "вычисление числа цилиндров$"
	JZ      L_0550
L_059C:	SHLD    BufHDD2+2	; число цилиндров
;;	LXI  H, 00001h		;
;;	SHLD	BufHDD2+6	; число головок
;;	SHLD	BufHDD2+12	; число секторов
;;	SHLD	BufHDD2+2	; число цилиндров
;;	SHLD	BufHDD2		; затираем первое слово -- признак ошибки
	XRA  A
	STA	BufHDD2+1	; признак расчётов
	MVI  A, 010h	; 1xH = сброс на цилиндр 0 (x = step rate)
	OUT     057h	; Запись:	регистр команды
L_04N0: LHLD	BufHDD2+6	; число головок
	XRA  A
	CMP  H
	JNZ	L_04ER	; > 255
	ORA  L
	JZ	L_04ER	; = 0
	CPI	011h
	JNC	L_04ER	; >= 17
	SHLD	D_MGOL
	LHLD	BufHDD2+12	; число секторов
	XRA  A
	CMP  H
	JNZ	L_04ER	; > 255
	ORA  L
	JZ	L_04ER	; = 0
;	CPI	0FFh
;	JNC	L_04ER	; = 255
	SHLD	D_MSEC
	LHLD	BufHDD2+2	; число цилиндров
	MOV  A, H
	ORA  L	
	JZ	L_04ER	; = 0
	SHLD	D_MCIL
; подтверждение значений
	CALL    L_0A56	; вывод строки далее до "$"
	.db "секторов : $"
	LHLD	D_MSEC
	CALL    L_0B3F	; вывод числа из HL
L_04EA: LXI  H, 00100h
	CALL    L_110F	; ввод шестнадцатиричного числа
	JZ      L_04EA
	LDA     L_1192
	ANA  A
	JZ      L_04FS
	CALL	L_1176	; проверка на HL=0
	JZ      L_04EA
	SHLD    D_MSEC	; всего секторов
L_04FS:	CALL    L_0A56	; вывод строки далее до "$"
	.db "головок  : $"
	LHLD	D_MGOL
	CALL    L_0B3F	; вывод числа из HL
L_053D: LXI  H, 00011h
	CALL    L_110F	; ввод шестнадцатиричного числа
	JZ      L_053D
	LDA     L_1192
	ANA  A
	JZ      L_055S
	CALL	L_1176	; проверка на HL=0
	JZ      L_053D
	SHLD    D_MGOL	; всего головок
L_055S:	CALL    L_0A56	; вывод строки далее до "$"
	.db "цилиндров: $"
	LHLD    D_MCIL	; всего цилиндров
	CALL    L_0B3F	; вывод числа из HL
L_05B3: LXI  H, 0FFFFh
	CALL    L_110F	; ввод шестнадцатиричного числа
	JZ      L_05B3
	LDA     L_1192
	ANA  A
	JZ      L_05C6
	CALL	L_1176	; проверка на HL=0
	JZ      L_05B3
	SHLD    D_MCIL	; всего цилиндров
L_05C6:	LXI  D, 00000h
	LDA     D_MSEC	; всего секторов
	LHLD    D_MCIL	; всего цилиндров
	CALL    L_0ED2
	LDA     D_MGOL	; всего головок
	CALL    L_0ED2
	MVI  A, 020h
	CALL    L_0ED2
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "секторов (LBA): $"
	LXI  H, L_0F0B
	CALL	L_QHEX	; вывод 4 байт в шестнадцатиричном формате (L_0F0C,L_0F0B,L_0F0A,L_0F09)
	LDA	BufHDD2+1
	ORA  A
	JZ	L_05CZ	; пропускаем, если была ошибка определения параметров
	CALL    L_0A5C	; вывод строки далее до "$"
	.db 00Dh,00Ah,"секторов (LBA) из ID диска: $"
	LXI  H, BufHDD2+122
	CALL	L_QHEX	; вывод 4 байт в шестнадцатиричном формате (BufHDD2+123,+122,+121,+120)
L_05CZ:	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Доступная память НЖМД "
	.db "составляет$"
	LDA	L_0F0B+1
	ORA  A
	JNZ	L_05CX	; объём > FFFFh
	LHLD    L_0F0F	;
	MVI  A, 01Fh
	CMP  H
	JNC	L_05CY	; объём <= 1Fxx
L_05CX:	LXI  H, 01FFFh	; =8191 мегабайт -- максимальный объём для Вектора
L_05CY:	CALL    L_0B3F	; вывод числа из HL
	CALL    L_0A5C	; вывод строки далее до "$"
	.db "мегабайт$"
	CALL    L_0AA3	; вывод сообщения о продолжении
	.db "Конец вычисления параметров "
	.db "НЖМД.$"
	JZ      L_045F
;
L_0671: CALL    L_0A08	; вывод строки и отбивки дефисами
	.db "Верификация секторов$"
	CALL    L_0B17	; вывод сообщения с "да/нет?"
	.db "Выполнить$"
	JNZ     L_073E	;L_0763
	CALL    L_0B17	; вывод сообщения с "да/нет?"
	.db "Полная верификация$"
	LXI  H, 00000h
	JZ      L_06BZ
	LHLD    D_MCIL	; всего цилиндров
	MOV  A, H
	ORA  L
	JZ	L_06BZ	; а вдруг там 0000?
	DCX  H
	DCX  H
	DCX  H		; проверяем только два последних цилиндра
L_06BZ:	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "$"
	XRA  A
	STA     Lx10BZ+1	; для вывода ошибок
	MVI  A, 0A0h	; 1010 0000	
	OUT     056h	; Биты определяют устройство и головку для операции чтения/записи, режим CHS
	MOV  A, L
	OUT     054h	; Цилиндр, младшие биты
	MOV  A, H
	OUT     055h	; Цилиндр, старшие биты
	MVI  A, 001h
	OUT     053h	; Номер логического сектора для чтения/записи
L_06C6:	XRA  A
;	OUT     052h	; Счетчик числа секторов для операции чтения/записи
;	MVI  A, 041h	; 4xH = чтение для верификации (x = 1 -- без повторов)
	CALL    L_VRF	;L_0E58	; << отправка команды
;	ANI     0FDh	; отбрасываем бит 1
;	CPI     050h	; "поиск завершен" + "устройство готово к операции"
	JZ      L_0710	; >>
	MVI  A, 001h	; (не быстрая верификация)
;	OUT     052h	; Счетчик числа секторов для операции чтения/записи
;	MVI  A, 041h	; 4xH = чтение для верификации (x = 1 -- без повторов)
	CALL    L_VRF	;L_0E58	; << отправка команды
;	ANI     0FDh	; отбрасываем бит 1
;	CPI     050h	; "поиск завершен" + "устройство готово к операции"
	JZ      L_0710	; >>
	CPI     051h
	JNZ     L_070D	; >> предыдущая команда закончилась с ошибкой
	LHLD    D_MCIL	; всего цилиндров
	DCX  H
	IN      055h	; Цилиндр, старшие биты
	CMP  H
	JC      L_070Z	; >> меньше MAX
	JNZ     L_073E	;>>> {больше MAX} конец верификации
	IN      054h	; Цилиндр, младшие биты
	CMP  L
	JC      L_070Z	; >> меньше MAX
	JNZ     L_073E	;>>> {больше MAX} конец верификации
L_070Z:	IN      051h	; Регистр ошибок
	CPI     004h	; ID сектора не найден
	JZ      L_073E	;>>> конец верификации
L_070D: CALL    L_10B9	; вывод ошибки с номером головки/сектора/цилиндра
L_0710:	CALL    L_1199	; переход к следующему сектору / головке / цилиндру
	CALL    L_0AF5	; "Прервать?"
	JZ      L_073E	;>>>
	JMP     L_06C6	; повтор
;
L_VRFL:	LHLD    L_0F09
	XCHG		; (L)(DE) (24 бита) -- номер сектора
	LHLD    L_0F0B
	MOV  A, L	; LDA     BUFSEC+2
	OUT     055h	; LBA [23..16]
	MOV  A, E	; LDA     BUFSEC
	OUT     053h	; LBA [7..0]
	MOV  A, D	; LDA     BUFSEC+1
	OUT     054h	; LBA [15..8]
	MVI  A, 0E0h	; 1110 0000
	OUT     056h	; режим и LBA[27..24]
	MVI  A, 001h	; количество читемых/записываемых секторов
L_VRF:	OUT     052h	; Счетчик числа секторов для операции чтения/записи
	MVI  A, 041h	; 4xH = чтение для верификации (x = 1 -- без повторов)
	CALL    L_0E58	; << отправка команды
	ANI     0FDh	; отбрасываем бит 1
	CPI     050h	; "поиск завершен" + "устройство готово к операции"
	RET
;
L_0E58: PUSH PSW	; << отправка команды
L_0E59:	CALL    L_D9D9	; ожидание готовности НЖМД
	JNC     L_0E73
	CALL    L_0B6N	; вывод A в шестнадцатиричном формате с новой строки
	CALL    L_0A7C	; вывод ошибки (?) без перевода строки
	.db ": не готов НЖМД$"
	JZ      L_0E59
L_0E73: POP  PSW
	OUT     057h
L_0E76: CALL    L_D9D9	; ожидание готовности НЖМД
	RNC
	PUSH PSW
	CALL    L_0A7B	; вывод ошибки (?)
	.db "адаптер не может завершить "
	.db "выполнение команды$"
	POP  PSW
	JZ      L_0E76
	RET
;
L_1199: LHLD    D_MSEC	; всего секторов
	INR  L
	IN      053h
	INR  A
	OUT     053h	; Номер логического сектора для чтения/записи
	CMP  L
	RC
	LHLD    D_MGOL	; всего головок
	MVI  A, 001h
	OUT     053h	; Номер логического сектора для чтения/записи
	IN      056h
	ANI     00Fh
	INR  A
	ORI     0A0h	; 1010 0000	
	OUT     056h	; Биты определяют устройство и головку для операции чтения/записи, режим CHS
	ANI     00Fh
	CMP  L
	RC
	MVI  A, 0A0h	; 1010 0000	
	OUT     056h	; Биты определяют устройство и головку для операции чтения/записи, режим CHS
	IN      054h
	MOV  L, A
	IN      055h
	MOV  H, A
	INX  H
	MOV  A, L
	OUT     054h	; Цилиндр, младшие биты
	MOV  A, H
	OUT     055h	; Цилиндр, старшие биты
	CALL    L_0A5C	; вывод строки далее до "$"
	.db 00Dh,"$"
	MOV  A, H
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	MOV  A, L
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	CALL    L_0A5C	; вывод строки далее до "$"
	.db "(H)$"
	RET
;
L_10B9:	CALL    L_0B6N	; вывод A в шестнадцатиричном формате с добавлением перевода строки в начале
	CALL    L_0A5C	; вывод cтроки до "$"
	.db ": Сектор$"
	IN      053h
	MVI  H, 000h
	MOV  L, A
	CALL    L_0B3F	; вывод числа из HL
	CALL    L_0A5C	; вывод строки далее до "$"
	.db ", Головка$"
	IN      056h
	ANI     00Fh
	MVI  H, 000h
	MOV  L, A
	CALL    L_0B3F	; вывод числа из HL
	CALL    L_0A5C	; вывод строки далее до "$"
	.db ", Цилиндр$"
	IN      054h
	MOV  L, A
	IN      055h
	MOV  H, A
	CALL    L_0B3F	; вывод числа из HL
	CALL    L_0B39	; перевод строки и пробел
Lx10BZ:	MVI  A, 000h
	ORA  A
	JZ	L_10BX	; задать вопрос
	DCR  A
	RNZ		; расшифровка не нужна
L_10BY:	IN      057h
	XRI     050h
	LXI  D, L_0F6C
	CALL    L_1098
	IN      057h
	ANI     001h
	RZ		; >> Ошибки не было
	IN      051h
	LXI  D, L_0FE2
	CALL    L_1098
L_10CZ:	CALL    L_0B39	; перевод строки и пробел
	RET
;	
L_10BX:	CALL    L_0B1X	; вывод сообщения с "да/нет?" (без перевода строки)
	.db "ОШИБКА. Нужна расшифровка "
	.db "ошибки$"
	PUSH PSW
	CALL    L_0B39	; перевод строки и пробел
	POP  PSW
	LXI  H, Lx10BZ+1
 	MVI  M, 002h
	RNZ		;JNZ	L_10CZ	; >> не нужна
	DCR  M
	JMP	L_10BY	; >> нужна
;
L_0F6C: .dw S_0F7C
	.dw S_0F89
	.dw S_0F97
	.dw S_0FA5
	.dw S_0FB7
	.dw S_0FC5
	.dw 00000h
	.dw 00000h
S_0F7C:	.db "адаптер занят$"
S_0F89:	.db "НЖМД не готов$"
S_0F97:	.db "ошибка записи$"
S_0FA5:	.db "поиск не завершен$"
S_0FB7:	.db "ожидание данных$"
S_0FC5:	.db "корректируемая ошибка данных$"
;
L_0FE2: .dw S_0FF2
	.dw S_100D
	.dw 00000h
	.dw S_102C
	.dw 00000h
	.dw S_1044
	.dw S_1060
	.dw S_107E
S_0FF2:	.db "обнаружен дефектный сектор$"
S_100D:	.db "корректируемая ошибка данных$"
S_102C:	.db "идентификатор не найден$"
S_1044:	.db "выполнение команды прервано$"
S_1060:	.db "не обнаружена нулевая дорожка$"
S_107E:	.db "адресный маркер не найден$"
;
L_1098: ADD  A
	JNC     L_10B2
	PUSH PSW
	PUSH D
	LDAX D
	INX  D
	MOV  L, A
	LDAX D
	MOV  H, A
	ORA  L
	JZ      L_10B0
;	CALL    L_0B39	; перевод строки и пробел
	XCHG
	MVI  C, 009h
	CALL    00005h
L_10B0: POP  D
	POP  PSW
L_10B2: INX  D
	INX  D
	ANA  A
	JNZ     L_1098
	RET
;
L_073E: CALL    L_0AA3	; вывод сообщения о продолжении
	.db "Конец верификации секторов$"
	JZ      L_0671
L_0763: CALL    L_0A08	; вывод строки и отбивки дефисами
	.db "Проверка чтения сектора НЖМД$"
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Введите:$"
L_0857:	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "- номер сектора, 1..$"
	LHLD    D_MSEC	; всего секторов
	MVI  H, 000h
	MOV  A, L
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	INX  H
	CALL    L_110F	; ввод шестнадцатиричного числа
	MOV  A, L
	STA	D_SECT+1	; номер сектора
	JZ      L_0857
	MOV  A, H
	ORA  L
	JNZ     L_0897
	CALL    L_0A7B	; вывод ошибки (?)
	.db "Неправильное значение$"
	JMP     L_0857
;
L_0897: CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "- номер головки, 0..$"
	LHLD    D_MGOL	; всего головок
	MVI  H, 000h
	MOV  A, L
	DCR  A
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	CALL    L_110F	; ввод шестнадцатиричного числа
	MOV  A, L
	STA	D_GOL+1	; номер головки
	JZ      L_0897
L_08B6: CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "- номер цилиндра, 0..$"
	LHLD    D_MCIL	; всего цилиндров
	DCX  H
	MOV  A, H
	ORA  A
	CNZ	L_0B6F	; вывод A в шестнадцатиричном формате
	MOV  A, L
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	INX  H
	CALL    L_110F	; ввод шестнадцатиричного числа
	SHLD    D_CIL+1	; номер цилиндра
	JZ      L_08B6
L_08D4: XRA  A
	STA	D_RERR	; очистка признака ошибки сравнения
;	STA     L_0F6B
;	STA     L_0BB4
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Чтение в режиме CHS$"
L_08DQ:	LXI  H, BufHDD2	; второй буфер
	MVI  B, 0
	CALL    L_RWCH	; чтение в буфер по адресу в HL
	JNC	L_08DX	; всё ок
	CALL    L_0B6N	; вывод A в шестнадцатиричном формате с новой строки
	CALL    L_0A7C	; вывод ошибки (?) без перевода строки
	.db ": чтение$"
	JZ	L_08DQ	; повторить
L_08DX:	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Повторное чтение$"
	LXI  H, BufHDD1	; начало буфера под сохранение данных с сектора диска
L_08DP:	MVI  B, 0
	CALL    L_RWCH	; чтение в буфер по адресу в HL
	JNC	L_08DY	; всё ок
	CALL    L_0B6N	; вывод A в шестнадцатиричном формате с новой строки
	CALL    L_0A7C	; вывод ошибки (?) без перевода строки
	.db ": чтение$"
	JZ	L_08DP	; повторить
L_08DY:	CALL    L_0DD4	; сравнение двух областей данных (208h байт) BufHDD1 и BufHDD2
;	JZ      L_08D4	; повтор чтения
;	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
;	.db "Ошибок нет$"
	PUSH PSW
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Чтение в режиме LBA, "
	.db "номер сектора: $"
	LHLD    D_CIL+1	; номер цилиндра
	LXI  D, 00000h
	LDA     D_MGOL	; всего головок
	CALL    L_0ED2	; DEHL = цилиндр * всего головок
	PUSH H
	POP  B
	LHLD    D_GOL+1	; номер головки
	MVI  H, 0
	DAD  B	
	JNC	$+4
	INX  D
	LDA     D_MSEC	; всего секторов
	CALL    L_0ED2	; DEHL = DEHL * всего секторов
	PUSH H
	POP  B
	LHLD    D_SECT+1	; номер сектора
	MVI  H, 0
	DCX  H
	DAD  B	
	JNC	$+4
	INX  D
	SHLD    L_0F09	; сохранение номера сектора LBA
	XCHG
	SHLD    L_0F0B	
;	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
;	.db "Номер сектора LBA: $"
	LXI  H, L_0F0B
	CALL	L_QHEX	; вывод 4 байт в шестнадцатиричном формате (L_0F0C,L_0F0B,L_0F0A,L_0F09)
	CALL	L_RLBA	; LBA чтение в BufHDD2 с выводом ошибок
	POP  PSW
	CNZ	L_0DD4	; сравнение двух областей данных BufHDD1 и BufHDD2
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Повторное чтение в LBA$"
	CALL	L_RLBA	; LBA чтение в BufHDD2 с выводом ошибок
	CALL    L_0DD4	; сравнение двух областей данных BufHDD1 и BufHDD2
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Содержимое первых 64 байт "
	.db "сектора:", 00Ah, 00Dh, "$"
	LXI  H, BufHDD1	; начало буфера под сохранение данных с сектора диска
	LXI  B,	00410h
	MVI  D, 000h	; КС
L_08XX:	MOV  A, M
	ADD  D
	MOV  D, A
	MOV  A, M
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	CALL    L_0A5C	; вывод строки далее до "$"
	.db " $"
	INX  H
	DCR  C
	JNZ	L_08XX
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "$"
	MVI  C, 010h
	DCR  B
	JNZ	L_08XX
	CALL    L_0A5C	; вывод строки далее до "$"
	.db "КС = $"
	MOV  A, D
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	CALL    L_0AA3	; вывод сообщения о продолжении
	.db "Конец проверки чтения$"
	JZ      L_0763
	LDA	D_RERR
	ORA  A
	JNZ	L_ENDT	; при ошибках сравнения запись не проверяем
	CALL    L_0B17	; вывод сообщения с "да/нет?"
	.db "Выполнить проверку записи$"
	JNZ     L_09CB
	XRA  A
	STA	D_RERR	; очистка признака ошибки сравнения
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Запись сектора с верификацией$"
L_0912: LXI  H, BufHDD1
	CALL    L_WLBA	; запись данных на диск
	CALL    L_VRFL	; верификация сектора
	JZ	L_091X	; нет ошибок
	CALL    L_0A7B	; вывод ошибки (?)
	.db "проверка записи сектора$"
	JZ      L_0912
L_091X:	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Чтение записанного$"
	CALL	L_RLBA	; LBA чтение в BufHDD2 с выводом ошибок
	CALL    L_0DD4	; сравнение двух областей данных BufHDD1 и BufHDD2
	JZ      L_0912	; >> не записалось
L_0943: CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Запись контрольных данных$"
	LXI  H, BufHDD3	; паттерн для записи
	PUSH H
	MVI  C, 000h	; счётчик
	LXI  D, 0AA55h	; паттерн
L_094X:	MOV  M, D
	INX  H
	MOV  M, C
	INX  H
	INR  C
	MOV  M, E
	INX  H
	MOV  M, C
	INX  H
	INR  C
	JNZ	L_094X
	POP  H
;z;	CALL    L_0CCE	; контрольная запись
	CALL    L_WLBA	; запись данных на диск
	CALL    L_VRFL	; верификация сектора
	JZ	L_094Y	; нет ошибок
	CALL    L_0A7B	; вывод ошибки (?)
	.db "проверка записи сектора$"
	JZ      L_0943
L_094Y:	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Чтение$"
	CALL	L_RLBA	; LBA чтение в BufHDD2 с выводом ошибок
	LXI  H, BufHDD3	; паттерн для записи
	CALL    L_0DD7	; сравнение двух областей данных (200h байт)
	JZ      L_0943
L_094Z:	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Восстановление первоначального "
	.db "содержания сектора$"
	LXI  H, BufHDD1
	CALL    L_WLBA	; запись данных на диск
	CALL    L_VRFL	; верификация сектора
	JZ	L_094R	; нет ошибок
	CALL    L_0A7B	; вывод ошибки (?)
	.db "проверка записи сектора$"
	JZ      L_094Z
L_094R:	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Чтение$"
	CALL	L_RLBA	; LBA чтение в BufHDD2 с выводом ошибок
	CALL    L_0DD4	; сравнение двух областей данных (200h байт)
	JZ      L_094Z
L_09CB: CALL    L_0AA3	; вывод сообщения о продолжении
	.db "Конец проверки записи "
	.db "и чтения$"
	JZ      L_0763
L_ENDT:	CALL    L_0AA3	; вывод сообщения о продолжении
	.db "Конец теста НЖМД$"
	JZ      L_0100
	JMP     00000h	; >>>>>>>>>>> выход
;
;----------------------------------------------------------------------------------------
L_RLBA:	MVI  B, 0	; LBA чтение в BufHDD2 с выводом ошибок
	LHLD    L_0F0B
	MOV  C, L
	LHLD    L_0F09
	XCHG		; (C)(DE) (24 бита) -- номер сектора
	LXI  H, BufHDD2	; второй буфер
	CALL    L_RWHD	; чтение LBA в буфер по адресу в HL
	RNC		; >>> всё ок
	CALL    L_0B6N	; вывод A в шестнадцатиричном формате с новой строки
	CALL    L_0A7C	; вывод ошибки (?) без перевода строки
	.db ": чтение$"
	JZ	L_RLBA	; повторить
	RET
;
L_WLBA:	SHLD	LxWLB1+1	; LBA запись из буфера HL с выводом ошибок
L_WLB0:	MVI  B, 0FFh
	LHLD    L_0F0B
	MOV  C, L
	LHLD    L_0F09
	XCHG		; (C)(DE) (24 бита) -- номер сектора
LxWLB1:	LXI  H, 00000h	; буфер
	CALL    L_RWHD	; чтение LBA в буфер по адресу в HL
	RNC		; >>> всё ок
	CALL    L_0B6N	; вывод A в шестнадцатиричном формате с новой строки
	CALL    L_0A7C	; вывод ошибки (?) без перевода строки
	.db ": запись$"
	JZ	L_WLB0	; повторить
	RET
;
;----------------------------------------------------------------------------------------
; ПП сравнения двух областей данных
L_0DD4:	LXI  H, BufHDD1
L_0DD7:	LXI  D, BufHDD2
	LXI  B, 0200h	; сколько сравнивать
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "Сравнение$"
L_0DE4: LDAX D
	CMP  M
	JNZ     L_0DF5
	INX  H
	INX  D
	DCX  B
	MOV  A, B
	ORA  C
	JNZ     L_0DE4
	INR  A
	CALL    L_0A5C	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db ": ошибок нет$"
	RET
;
L_0DF5:	LXI  H,	D_RERR
	INR  M		; инкремент количества ошибок
	CALL    L_0A5C	; вывод строки далее до "$"
	.db ": несовпадение на байте$"
	MOV  A, C	; инвертируем BC
	CMA
	MOV  C, A
	MOV  A, B
	CMA
	MOV  B, A
	LXI  H, 0202h
;	LHLD    L_0C52	; загружаем, сколько сравнивали (0104h)
;	INX  H		; HL = HL + 1
;	DAD  H		; HL = HL * 2
	DAD  B		; HL = 0208h - BC
	CALL    L_0B3F	; вывод номера байта, на котором возникла ошибка
	CALL    L_0A7B	; вывод ошибки (?)
	.db " $"
	XRA  A
L_0E05: RET
;
; ПП вывода строки и отбивки дефисами
L_0A08: CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db "----------------------------"
	.db "----------------------------"
	.db "------------------$"
;
; ПП вывода cтроки до "$" с добавлением перевода строки в начале
L_0A56: CALL    L_0A5C	; вывод строки далее до "$"
	.db 00Dh, 00Ah, "$"
;
; ПП вывода строки от адреса в стеке до "$" с возвратом на адрес после строки
L_0A5C: XTHL		; HL <-> стек (адрес возврата)
	CALL    L_0A62
	XTHL
	RET
;
; ПП вывода точки
L_DOT:	MVI  E, '.'
	MVI  C, 002h
	JMP	00005h
;
L_0A62: PUSH PSW
	PUSH D
	PUSH B
L_0A65: MOV  A, M
	INX  H
	CPI     024h
	JZ      L_0A77
	MOV  E, A
	PUSH H
	MVI  C, 002h
	CALL    00005h
	POP  H
	JMP     L_0A65
;
L_0A77: POP  B
	POP  D
	POP  PSW
	RET
;
; ПП вывода строки с ошибкой
L_0A7B: CALL    L_0B39	; перевод строки и пробел
L_0A7C:	XTHL		; без перевода строки
	CALL    L_0A62
	XTHL
	CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db 01Bh, 062h
	.db "       ОШИБКА        "
	.db 01Bh, 061h, "$"
	JMP     L_0AAB
;
; ПП вывода сообщения о продолжении
L_0AA3: CALL    L_0B39	; перевод строки и пробел
	XTHL
	CALL    L_0A62
	XTHL
L_0AAB: PUSH H
	PUSH D
	PUSH B
L_0AAE: CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db " -Продолжить/Повторить/Прервать"
	.db " ? (C/R/A)$"
	MVI  C, 001h
	CALL    00005h
	CPI     041h
	JZ      00000h
	CPI     052h
	JZ      L_0AF1
	CPI     043h
	JZ      L_0AF0
	JMP     L_0AAE
;
L_0AF0: INR  A
L_0AF1: POP  B
	POP  D
	POP  H
	RET
;
L_0AF5: PUSH B		; "Прервать?"
	PUSH H
	PUSH D
	MVI  C, 00Bh
	CALL    00005h
	ANA  A
	JZ      L_0B11
	MVI  C, 006h
	MVI  E, 0FFh
	CALL    00005h
	CALL    L_0B17	; вывод сообщения с "да/нет?"
	.db "Прервать$"
L_0B11: CPI     059h
	POP  D
	POP  H
	POP  B
	RET
;
; ПП вывода сообщения с "да/нет?"
L_0B17: CALL    L_0B39	; перевод строки и пробел
L_0B1X:	XTHL
	CALL    L_0A62
	XTHL
	CALL    L_0A5C	; вывод строки далее до "$"
	.db " ? (Y/N)$"
	PUSH H
	PUSH D
	PUSH B
	MVI  C, 001h
	CALL    00005h
	CPI     059h
	POP  B
	POP  D
	POP  H
	RET
;
L_0B39: CALL    L_0A56	; вывод cтроки до "$" с добавлением перевода строки в начале
	.db " $"
	RET
;
; вывод 4 байт в HEX с адреса в HL
L_QHEX:	INX  H
	MOV  A, M
	ORA  A
	MOV  B, A
	CNZ	L_0B6F	; вывод A в шестнадцатиричном формате
	DCX  H
	MOV  C, M
	MOV  A, B
	ORA  C
	MOV  B, A
	MOV  A, C
	CNZ	L_0B6F	; вывод A в шестнадцатиричном формате
	DCX  H
	MOV  C, M
	MOV  A, B
	ORA  C
	MOV  A, C
	CNZ	L_0B6F	; вывод A в шестнадцатиричном формате
	DCX  H
	MOV  A, M
	CALL	L_0B6F	; вывод A в шестнадцатиричном формате
	CALL	L_0A5C	; вывод строки далее до "$"
	.db " (H)$"
	RET
;
; вывод значения из HL в HEX и DEC
L_0B3F: CALL    L_0A5C	; вывод строки далее до "$"
	.db " $"
	SHLD    Lx0B5X+1	;L_0B6D
	MOV  A, H
	ORA  A
	CNZ    L_0B6F	; вывод A в шестнадцатиричном формате
	MOV  A, L
	CALL    L_0B6F	; вывод A в шестнадцатиричном формате
	CALL    L_0A5C	; вывод строки далее до "$"
	.db "(H) = $"
Lx0B5X:	LXI  D, 00000h	;L_0B6C
;	MVI  C, 032h	; Вызов операций расширенной БДОС -- вывод в десятичном виде
	CALL    L_CB86	;00005h	;
	CALL    L_0A5C	; вывод строки далее до "$"
	.db "(D) $"
	RET
;
;L_0B6C: .db 0F3h	; блок параметров для вызова операции расширенной БДОС
;L_0B6D: .dw 00000h
;
L_0B6N:	CALL	L_0B39	; перевод строки и пробел
; вывод A в шестнадцатиричном формате
L_0B6F: PUSH H
	PUSH D
	PUSH B
	PUSH PSW
	RRC
	RRC
	RRC
	RRC
	CALL    L_0B82	; вывод полубайта в шестнадцатиричном формате
	POP  PSW
	CALL    L_0B82	; --
	POP  B
	POP  D
	POP  H
	RET
;
L_0B82:	ORI	0F0h	; вывод полубайта в шестнадцатиричном формате
	DAA
	CPI	060h
	SBI	01Fh
	MOV  E, A
	MVI  C, 002h
	JMP     00005h
;
; вывод DE в десятичном формате
L_CB86: PUSH D
	MVI  B, 085h
	LXI  H, L_CBD1
L_CB8C: MOV  E, M
	INX  H
	MOV  D, M
	INX  H
	XTHL
	MVI  C, 030h
L_CB93: MOV  A, L
	SUB  E
	MOV  L, A
	MOV  A, H
	SBB  D
	MOV  H, A
	JC      L_CBA0
	INR  C
	JMP     L_CB93
;
L_CBA0: DAD  D
	MOV  A, B
	ORA  A
	JP      L_CBB7
	PUSH PSW
	MOV  A, C
	CPI     030h
	JZ      L_CBBE
	CALL    L_CBF6	; печать символа из А
	POP  PSW
	ANI     07Fh
	MOV  B, A
	JMP     L_CBCA
;
L_CBB7: MOV  A, C
	CALL    L_CBF6	; печать символа из А
	JMP     L_CBCA
;
L_CBBE: POP  PSW
	ANI     07Fh
	CPI     001h
	JNZ     L_CBCA
	MOV  B, A
	JMP     L_CBB7
;
L_CBCA: XTHL
	DCR  B
	JNZ     L_CB8C
	POP  D
	RET
;
L_CBF6: PUSH H		; ПП печатает символ из А
	PUSH B
	PUSH D
	MOV  E, A
	MVI  C, 002h
	CALL     00005h
	POP  D
	POP  B
	POP  H
	RET
;
L_CBD1: .dw 02710h	; = 10000
	.dw 003E8h	; = 1000
	.dw 00064h	; = 100
	.dw 0000Ah	; = 10
	.dw 00001h	; = 1
;
; ПП ввода значения в шестнадцатиричном формате
L_110F: PUSH H
L_1110:	CALL    L_0A5C	; вывод строки далее до "$"
	.db " (H) ?$"
	LXI  H, L_1192
	MVI  B, 007h
L_111F: MVI  M, 000h
	INX  H
	DCR  B
	JNZ     L_111F
	LXI  D, L_1190
	MVI  C, 00Ah
	CALL    00005h
	LXI  D, L_1192
	LXI  H, 00000h
L_1134: LDAX D
	CPI     00Dh	; <ВК>
	JZ      L_116X
	INX  D
	ANA  A
	JZ      L_1160
	SUI     030h
	JC      L_1174	; <<< было 1175!!!
	CPI     00Ah
	JC      L_1150
	ADI     0F9h
	CPI     00Ah
	JC      L_1174
	CPI     010h
	JNC     L_1174
L_1150: DAD  H
	DAD  H
	DAD  H
	DAD  H
	ADD  L
	MOV  L, A
	MOV  A, H
	ACI     000h
	MOV  H, A
	JC      L_1174
	JMP     L_1134
;
L_116X:	XRA  A
	STAX D
L_1160: POP  D
	MOV  A, H
	CMP  D
	JNZ     L_116E
	MOV  A, L
	CMP  E
	JNZ     L_116E
	JMP     L_1175
;
L_116E: JNC     L_1175
	XRA  A
	INR  A
	RET
;
L_1174: POP  H
L_1175: PUSH H
	CALL    L_0A7B	; вывод ошибки (?)
	.db "Не правильный номер$"
	XRA  A
	POP  H
	RET
;
L_1176:	MOV  A, H	; проверка на ввод нулевого значения
	ORA  L
	JZ      L_1175
	RET
; DEHL * A -> L_0F0D, L_0F0F
L_0ED2: SHLD    L_0F09	; вычисление секторов и объёма НЖМД
	XCHG
	SHLD    L_0F0B
	LXI  H, 00000h
	SHLD    L_0F0D
	SHLD    L_0F0F
	MOV  B, A
L_0EE3: LHLD    L_0F0D
	XCHG
	LHLD    L_0F09
	DAD  D
	SHLD    L_0F0D
	LHLD    L_0F0F
	XCHG
	LHLD    L_0F0B
	JNC     L_0EF9
	INX  H
L_0EF9: DAD  D
	SHLD    L_0F0F
	DCR  B
	JNZ     L_0EE3
	LHLD    L_0F0F
	XCHG
	LHLD    L_0F0D
	RET
; 
; === ПП чтения/записи сектора НЖМД в режиме CHS ===
; Вход:	HL -- адрес буфера
;	B  -- чтение(=0)/запись(=FFh)
;	D_SECT+1 (db), D_CIL+1 (dw), D_GOL+1 (db)
; Вых.:	A и признак C -- код ошибки
;	
L_RWCH:
D_SECT:	MVI  A, 000h
	OUT     053h	; Номер логического сектора для чтения/записи
D_CIL:	LXI  D, 00000h
	MOV  A, E	; 
	OUT     054h	; Цилиндр, младшие биты
	MOV  A, D	; 
	OUT     055h	; Цилиндр, старшие биты
D_GOL:	MVI  A, 000h	;
	ORI	0A0h	; Выставляем биты 7 и 5, бит 6 = 0 (режим CHS), бит 4 = 0 (мастер)
	OUT     056h	; Биты определяют устройство и головку для операции чтения/записи, режим CHS
	JMP	L_RWHD+13
;
#include "IDE.inc"
;
L_1190: .db 005h  ; <_> - |     ■ ■| (offset 1090h)
	.db 000h  ; <_> - |        | (offset 1091h)
L_1192: .db 000h  ; <_> - |        | (offset 1092h)
	.db 000h  ; <_> - |        | (offset 1093h)
	.db 000h  ; <_> - |        | (offset 1094h)
	.db 000h  ; <_> - |        | (offset 1095h)
	.db 000h  ; <_> - |        | (offset 1096h)
	.db 000h  ; <_> - |        | (offset 1097h)
	.db 000h  ; <_> - |        | (offset 1098h)
;
D_MSEC: .dw 00000h	; всего секторов
D_MGOL: .dw 00000h	; всего головок
D_MCIL: .dw 00000h	; всего цилиндров
;
L_0F09: .dw 00000h	; младшие
L_0F0B: .dw 00000h	; старшие -- секторов LBA
L_0F0D: .dw 00000h	;
L_0F0F: .dw 00000h	; мегабайт
;
D_RERR:	.db 000h	; ошибка сравнения областей
;
	.org (((($ - 1) / 010h) + 1) * 010h)	;Выравнивание на адрес ХХX0h
BufHDD0:	; .db 000h  ; тут и далее 528 байт буфер для сохранения сектора диска при тестах
	.END
