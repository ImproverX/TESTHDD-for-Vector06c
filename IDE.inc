;============== подпрограммы для НЖМД ================
;
; === ПП чтения/записи сектора НЖМД ===
; Вход: (C)(DE) (24 бита) -- номер сектора
;	HL -- адрес буфера
;	B  -- чтение(=0)/запись(=FFh)
; Вых.:	A и признак C -- код ошибки
;	
L_RWHD:	MOV  A, C	; LDA     BUFSEC+2
	OUT     055h	; LBA [23..16]
	MOV  A, E	; LDA     BUFSEC
	OUT     053h	; LBA [7..0]
	MOV  A, D	; LDA     BUFSEC+1
	OUT     054h	; LBA [15..8]
	MVI  A, 0E0h	; 1110 0000
	OUT     056h	; режим и LBA[27..24]
	MVI  A, 001h	; количество читемых/записываемых секторов
	OUT     052h	; Счетчик числа секторов для операции чтения/записи
	MOV  E, B	; сохр.режим в Е [чтение(=0)/запись(=FFh)]
	ANA  B		; установка признака Z по B (A = 1)
	MVI  A, 020h	; 2xH = сектор чтения (x = retry and ECC-read)
	JZ      L_D8A9	; -> если чтение
	MVI  A, 030h	; 3xH = сектор записи (x = retry and ECC-read)
L_D8A9:	OUT     057h	; Запись:	регистр команды
	;;;LXI  H, D_EB00	; адрес буфера для чтения/записи данных
	CALL    L_D9D9	; проверка готовности НЖМД
	ANI     008h	; 0000 1000 :	запрос данных. Буфер ждет данных (занято)
	JZ      L_D9F9	; получение кода ошибки 2 и RET
	MVI  D, 000h	; D=0
	INR  E		; просто установка признака Z по значению E
	DCR  E
	JNZ     L_D8CF	; -> запись сектора
			; чтение сектора НЖМД
L_D8C1:	IN      050h	; Регистр данных. Чтение данных в буфер
	MOV  M, A
	INX  H
	IN      058h	; Регистр данных. Чтение данных в буфер
	MOV  M, A
	INX  H
L_D8Cx:	DCR  D		; счётчик
	JNZ     L_D8C1	; цикл
	JMP     L_D8DC	; выход из чтения
;
L_D8CF:	MOV  E, M	; запись сектора
	INX  H
	MOV  A, M
	OUT     058h	; Регистр данных. Запись данных из буфера
	MOV  A, E
	OUT     050h	; Регистр данных. Запись данных из буфера
	INX  H		; цикл записи
L_D8D8:	DCR  D		; счётчик
	JNZ     L_D8CF	; цикл
L_D8DC:	CALL    L_D9D9	; проверка готовности НЖМД
	ANI     0DDh	; 1101 1101 -- маскируем лишьнее
	MOV  C, A	; сохраняем код возврата в C
	ANI     008h	; 0000 1000 :	Буфер ждет данных (занято)
	JZ      L_D8xx	; если не занято
	MVI  A, 010h	; 1xH = сброс на цилиндр 0 (x = step rate)
	OUT     057h	; Запись:	регистр команды
L_D8xx:	MOV  A, C
	ANI	0D5h	; 1101 0101 -- маскируем "Буфер ждет данных (занято)"
	SUI     050h	; минус норм. код возврата
	JNZ     L_D9F9	; (<> 50h) & (<> 58h) -> получение кода ошибки 2 и RET
	STC
	CMC		; Признак C = 0
	RET		; >>>>>>>>>> выход из ПП c Z=1
;
; ПП проверки готовности НЖМД
L_D9D9:	PUSH D
	PUSH B
	MVI  D, 005h	; пять раз...
L_D9DD:	IN      057h	; регистр статуса
	ANI     0C0h	; 1100 0000
	CPI     040h	; 0100 0000 устройство готово к операции
	JZ      L_D9F2	; >> выход из цикла, при выходе A=40h
	DCX  B
	MOV  A, B
	ORA  C
	JNZ     L_D9DD	; цикл на 65536 попыток
	DCR  D
	JNZ     L_D9DD	; цикл на 5*65536 попыток, при выходе A,B,C,D=0
L_D9F2:	ANA  A		; устанавливаем признаки по А
	POP  B
	POP  D
	JZ      L_D9F8	; получение кода ошибки и RET
	IN      057h	; регистр статуса
	RET
;
; ПП чтения ошибки
L_D9F8:	POP  PSW	; чистка стека
L_D9F9:	IN      057h	; регистр статуса
	RRC		; сдвиг вправо, бит 0 заносится в признак С.
	IN      051h	; Чтение:	Регистр ошибок. Содержит признаки последней ошибки.
	JC      L_DA02	; если предыдущая команда закончилась с ошибкой
	XRA  A		; ошибки нет
L_DA02:	MOV  B, A	; В = код ошибки
	IN      057h	; регистр статуса
	MOV  C, A	; сохраняем результат
	ANI     020h	; выделяем ошибку "сбой записи"
	ORA  B
	MOV  B, A	; дополняем код ошибки в В
	MOV  A, C	; восст. Регистр данных.
	ANI     0C0h	; выделение сигналов "устройство готово" и "занято"
	CPI     040h	; уст.Z если "готово"
	MOV  A, B	; код ошибки в А
	JZ      L_E6AB	; переход, если сигнал "готово" (?было на L_DA15)
	MVI  A, 010h	; 1xH = сброс на цилиндр 0 (x = step rate) (?было ORI)
xxDA15:	OUT     05Fh	; Системный сброс (лучше не пользоваться, сходство с 57Н без обнуления микросхем жесткого диска).
L_E6AB:	STC		; Признак C = 1 (ошибка)
	RET
;
